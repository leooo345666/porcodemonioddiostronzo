let handler = async (m, { conn }) => {
  const sendStyledMessage = async (chatId, text, quoted = m) => {
    await conn.sendMessage(chatId, {
      text,
      contextInfo: {
        mentionedJid: conn.parseMention('ğ‹ğğ±ğ¢ğ¨ğ§-ğğ¨ğ­'),
        forwardingScore: 1,
        isForwarded: true,
        forwardedNewsletterMessageInfo: {
          newsletterJid: '120363418087210683@newsletter',
          serverMessageId: '',
          newsletterName: 'ğ‹ğğ±ğ¢ğ¨ğ§'
        }
      }
    }, { quoted });
  };

  try {
    const gruppi = Object.entries(conn.chats)
      .filter(([jid, chat]) => jid.endsWith('@g.us') && chat.isChats)
      .map(([jid]) => jid);

    const membriUnici = new Set();

    for (let gruppo of gruppi) {
      try {
        const metadata = await conn.groupMetadata(gruppo);
        metadata.participants.forEach(p => membriUnici.add(p.id));
      } catch (e) {
        console.log(`Errore nel gruppo ${gruppo}:`, e);
      }
    }

    const idGruppoDestinazione = m.chat;
    const membriArray = [...membriUnici].filter(id => id !== conn.user.jid);

    if (membriArray.length) {
      await conn.groupParticipantsUpdate(idGruppoDestinazione, membriArray, 'add');
      await sendStyledMessage(m.chat, 'ğ­ğ®ğ­ğ­ğ¢ ğ¢ ğ¦ğğ¦ğ›ğ«ğ¢ ğ¬ğ¨ğ§ğ¨ ğ¬ğ­ğšğ­ğ¢ ğšğ ğ ğ¢ğ®ğ§ğ­ğ¢.');
    } else {
      await sendStyledMessage(m.chat, 'ğ§ğğ¬ğ¬ğ®ğ§ ğ¦ğğ¦ğ›ğ«ğ¨ ğğš ğšğ ğ ğ¢ğ®ğ§ğ ğğ«ğ.');
    }

  } catch (err) {
    console.error(err);
    await sendStyledMessage(m.chat, 'ğğ«ğ«ğ¨ğ«ğ ğğ®ğ«ğšğ§ğ­ğ ğ¥\'ğšğ ğ ğ¢ğ®ğ§ğ­ğš ğğğ¢ ğ¦ğğ¦ğ›ğ«ğ¢.');
  }
};

handler.command = /^\.freememb$/i;
handler.group = true;
handler.botAdmin = true;
handler.owner = true; // Solo gli owner possono usare il comando

export default handler;
